// Code generated by protoc-gen-go.
// source: protos/golang.conradwood.net/apis/objectstore/objectstore.proto
// DO NOT EDIT!

/*
Package objectstore is a generated protocol buffer package.

It is generated from these files:
	protos/golang.conradwood.net/apis/objectstore/objectstore.proto

It has these top-level messages:
	ObjectMeta
	ExistResponse
	PutWithIDRequest
	GetRequest
	Object
	ListResponse
	ListRequest
	PutResponse
	GetResponse
	EvictRequest
	ByVersionRequest
	KeyList
*/
package objectstore

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// database object
type ObjectMeta struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	// the key under with which the client knows it
	Key string `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	// Number of times this object was updates
	Version uint64 `protobuf:"varint,3,opt,name=Version" json:"Version,omitempty"`
	// the service who submitted it
	Service string `protobuf:"bytes,4,opt,name=Service" json:"Service,omitempty"`
	// the user who submitted it
	Creator string `protobuf:"bytes,5,opt,name=Creator" json:"Creator,omitempty"`
	// when was it last retrieved? (unix timestamp)
	LastRetrieved uint32 `protobuf:"varint,6,opt,name=LastRetrieved" json:"LastRetrieved,omitempty"`
	// when was it created? (unix timestamp)
	Created uint32 `protobuf:"varint,7,opt,name=Created" json:"Created,omitempty"`
	// when was it updated? (unix timestamp)
	LastUpdated uint32 `protobuf:"varint,8,opt,name=LastUpdated" json:"LastUpdated,omitempty"`
	// the key under which to find it in the store (e.g. a filename)
	StoreKey string `protobuf:"bytes,9,opt,name=StoreKey" json:"StoreKey,omitempty"`
	// a store_id (which store is it in?)
	StoreID uint32 `protobuf:"varint,10,opt,name=StoreID" json:"StoreID,omitempty"`
	Expiry  uint32 `protobuf:"varint,11,opt,name=Expiry" json:"Expiry,omitempty"`
	// version of the STORE (global version)
	StoreVersion uint64 `protobuf:"varint,12,opt,name=StoreVersion" json:"StoreVersion,omitempty"`
}

func (m *ObjectMeta) Reset()                    { *m = ObjectMeta{} }
func (m *ObjectMeta) String() string            { return proto.CompactTextString(m) }
func (*ObjectMeta) ProtoMessage()               {}
func (*ObjectMeta) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ObjectMeta) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ObjectMeta) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *ObjectMeta) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *ObjectMeta) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *ObjectMeta) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *ObjectMeta) GetLastRetrieved() uint32 {
	if m != nil {
		return m.LastRetrieved
	}
	return 0
}

func (m *ObjectMeta) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *ObjectMeta) GetLastUpdated() uint32 {
	if m != nil {
		return m.LastUpdated
	}
	return 0
}

func (m *ObjectMeta) GetStoreKey() string {
	if m != nil {
		return m.StoreKey
	}
	return ""
}

func (m *ObjectMeta) GetStoreID() uint32 {
	if m != nil {
		return m.StoreID
	}
	return 0
}

func (m *ObjectMeta) GetExpiry() uint32 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *ObjectMeta) GetStoreVersion() uint64 {
	if m != nil {
		return m.StoreVersion
	}
	return 0
}

type ExistResponse struct {
	ID        string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	DoesExist bool   `protobuf:"varint,2,opt,name=DoesExist" json:"DoesExist,omitempty"`
}

func (m *ExistResponse) Reset()                    { *m = ExistResponse{} }
func (m *ExistResponse) String() string            { return proto.CompactTextString(m) }
func (*ExistResponse) ProtoMessage()               {}
func (*ExistResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ExistResponse) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *ExistResponse) GetDoesExist() bool {
	if m != nil {
		return m.DoesExist
	}
	return false
}

type PutWithIDRequest struct {
	ID      string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Content []byte `protobuf:"bytes,2,opt,name=Content,proto3" json:"Content,omitempty"`
	Expiry  uint32 `protobuf:"varint,3,opt,name=Expiry" json:"Expiry,omitempty"`
}

func (m *PutWithIDRequest) Reset()                    { *m = PutWithIDRequest{} }
func (m *PutWithIDRequest) String() string            { return proto.CompactTextString(m) }
func (*PutWithIDRequest) ProtoMessage()               {}
func (*PutWithIDRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *PutWithIDRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *PutWithIDRequest) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *PutWithIDRequest) GetExpiry() uint32 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

type GetRequest struct {
	ID string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (m *GetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *GetRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type Object struct {
	ID      string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Content []byte `protobuf:"bytes,2,opt,name=Content,proto3" json:"Content,omitempty"`
}

func (m *Object) Reset()                    { *m = Object{} }
func (m *Object) String() string            { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()               {}
func (*Object) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Object) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Object) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

type ListResponse struct {
	Objects []*ObjectMeta `protobuf:"bytes,1,rep,name=Objects" json:"Objects,omitempty"`
}

func (m *ListResponse) Reset()                    { *m = ListResponse{} }
func (m *ListResponse) String() string            { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()               {}
func (*ListResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ListResponse) GetObjects() []*ObjectMeta {
	if m != nil {
		return m.Objects
	}
	return nil
}

type ListRequest struct {
	Prefix string `protobuf:"bytes,1,opt,name=Prefix" json:"Prefix,omitempty"`
}

func (m *ListRequest) Reset()                    { *m = ListRequest{} }
func (m *ListRequest) String() string            { return proto.CompactTextString(m) }
func (*ListRequest) ProtoMessage()               {}
func (*ListRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ListRequest) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

type PutResponse struct {
	WasAdded bool `protobuf:"varint,1,opt,name=WasAdded" json:"WasAdded,omitempty"`
	DidExist bool `protobuf:"varint,2,opt,name=DidExist" json:"DidExist,omitempty"`
}

func (m *PutResponse) Reset()                    { *m = PutResponse{} }
func (m *PutResponse) String() string            { return proto.CompactTextString(m) }
func (*PutResponse) ProtoMessage()               {}
func (*PutResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PutResponse) GetWasAdded() bool {
	if m != nil {
		return m.WasAdded
	}
	return false
}

func (m *PutResponse) GetDidExist() bool {
	if m != nil {
		return m.DidExist
	}
	return false
}

type GetResponse struct {
	DoesExist bool    `protobuf:"varint,1,opt,name=DoesExist" json:"DoesExist,omitempty"`
	Object    *Object `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *GetResponse) Reset()                    { *m = GetResponse{} }
func (m *GetResponse) String() string            { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()               {}
func (*GetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *GetResponse) GetDoesExist() bool {
	if m != nil {
		return m.DoesExist
	}
	return false
}

func (m *GetResponse) GetObject() *Object {
	if m != nil {
		return m.Object
	}
	return nil
}

type EvictRequest struct {
	ID           string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	ReturnObject bool   `protobuf:"varint,2,opt,name=ReturnObject" json:"ReturnObject,omitempty"`
}

func (m *EvictRequest) Reset()                    { *m = EvictRequest{} }
func (m *EvictRequest) String() string            { return proto.CompactTextString(m) }
func (*EvictRequest) ProtoMessage()               {}
func (*EvictRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *EvictRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *EvictRequest) GetReturnObject() bool {
	if m != nil {
		return m.ReturnObject
	}
	return false
}

type ByVersionRequest struct {
	Version uint64 `protobuf:"varint,1,opt,name=Version" json:"Version,omitempty"`
}

func (m *ByVersionRequest) Reset()                    { *m = ByVersionRequest{} }
func (m *ByVersionRequest) String() string            { return proto.CompactTextString(m) }
func (*ByVersionRequest) ProtoMessage()               {}
func (*ByVersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ByVersionRequest) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type KeyList struct {
	Objects []*ObjectMeta `protobuf:"bytes,1,rep,name=Objects" json:"Objects,omitempty"`
}

func (m *KeyList) Reset()                    { *m = KeyList{} }
func (m *KeyList) String() string            { return proto.CompactTextString(m) }
func (*KeyList) ProtoMessage()               {}
func (*KeyList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *KeyList) GetObjects() []*ObjectMeta {
	if m != nil {
		return m.Objects
	}
	return nil
}

func init() {
	proto.RegisterType((*ObjectMeta)(nil), "objectstore.ObjectMeta")
	proto.RegisterType((*ExistResponse)(nil), "objectstore.ExistResponse")
	proto.RegisterType((*PutWithIDRequest)(nil), "objectstore.PutWithIDRequest")
	proto.RegisterType((*GetRequest)(nil), "objectstore.GetRequest")
	proto.RegisterType((*Object)(nil), "objectstore.Object")
	proto.RegisterType((*ListResponse)(nil), "objectstore.ListResponse")
	proto.RegisterType((*ListRequest)(nil), "objectstore.ListRequest")
	proto.RegisterType((*PutResponse)(nil), "objectstore.PutResponse")
	proto.RegisterType((*GetResponse)(nil), "objectstore.GetResponse")
	proto.RegisterType((*EvictRequest)(nil), "objectstore.EvictRequest")
	proto.RegisterType((*ByVersionRequest)(nil), "objectstore.ByVersionRequest")
	proto.RegisterType((*KeyList)(nil), "objectstore.KeyList")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ObjectStore service

type ObjectStoreClient interface {
	// Put (with a known ID). Maximum object RPC size applies.
	// Only suitable for tiny little objectlets
	PutWithID(ctx context.Context, in *PutWithIDRequest, opts ...grpc.CallOption) (*common.Void, error)
	// return an object by (error if it does not exist)
	// Maximum object RPC size applies.
	// Only suitable for tiny little objectlets
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*Object, error)
	// like PutWithID, but for large objects
	LPutWithID(ctx context.Context, opts ...grpc.CallOption) (ObjectStore_LPutWithIDClient, error)
	// like Get, but for large objects
	LGet(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (ObjectStore_LGetClient, error)
	// get a list of objects in store
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
	// sync disk and db
	TriggerCheckDisk(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error)
	// put an object, but only if it does not exist yet
	PutIfNotExists(ctx context.Context, in *PutWithIDRequest, opts ...grpc.CallOption) (*PutResponse, error)
	// get an object, if it exists
	TryGet(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// remove an object, return object if it was present
	Evict(ctx context.Context, in *EvictRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// get all object-keys with a version higher than...
	HigherOrSameThanVersion(ctx context.Context, in *ByVersionRequest, opts ...grpc.CallOption) (ObjectStore_HigherOrSameThanVersionClient, error)
	// check if key exists
	DoesExist(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*ExistResponse, error)
}

type objectStoreClient struct {
	cc *grpc.ClientConn
}

func NewObjectStoreClient(cc *grpc.ClientConn) ObjectStoreClient {
	return &objectStoreClient{cc}
}

func (c *objectStoreClient) PutWithID(ctx context.Context, in *PutWithIDRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/objectstore.ObjectStore/PutWithID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectStoreClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*Object, error) {
	out := new(Object)
	err := grpc.Invoke(ctx, "/objectstore.ObjectStore/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectStoreClient) LPutWithID(ctx context.Context, opts ...grpc.CallOption) (ObjectStore_LPutWithIDClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ObjectStore_serviceDesc.Streams[0], c.cc, "/objectstore.ObjectStore/LPutWithID", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectStoreLPutWithIDClient{stream}
	return x, nil
}

type ObjectStore_LPutWithIDClient interface {
	Send(*PutWithIDRequest) error
	CloseAndRecv() (*common.Void, error)
	grpc.ClientStream
}

type objectStoreLPutWithIDClient struct {
	grpc.ClientStream
}

func (x *objectStoreLPutWithIDClient) Send(m *PutWithIDRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *objectStoreLPutWithIDClient) CloseAndRecv() (*common.Void, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(common.Void)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectStoreClient) LGet(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (ObjectStore_LGetClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ObjectStore_serviceDesc.Streams[1], c.cc, "/objectstore.ObjectStore/LGet", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectStoreLGetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectStore_LGetClient interface {
	Recv() (*Object, error)
	grpc.ClientStream
}

type objectStoreLGetClient struct {
	grpc.ClientStream
}

func (x *objectStoreLGetClient) Recv() (*Object, error) {
	m := new(Object)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectStoreClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	out := new(ListResponse)
	err := grpc.Invoke(ctx, "/objectstore.ObjectStore/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectStoreClient) TriggerCheckDisk(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/objectstore.ObjectStore/TriggerCheckDisk", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectStoreClient) PutIfNotExists(ctx context.Context, in *PutWithIDRequest, opts ...grpc.CallOption) (*PutResponse, error) {
	out := new(PutResponse)
	err := grpc.Invoke(ctx, "/objectstore.ObjectStore/PutIfNotExists", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectStoreClient) TryGet(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := grpc.Invoke(ctx, "/objectstore.ObjectStore/TryGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectStoreClient) Evict(ctx context.Context, in *EvictRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := grpc.Invoke(ctx, "/objectstore.ObjectStore/Evict", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectStoreClient) HigherOrSameThanVersion(ctx context.Context, in *ByVersionRequest, opts ...grpc.CallOption) (ObjectStore_HigherOrSameThanVersionClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ObjectStore_serviceDesc.Streams[2], c.cc, "/objectstore.ObjectStore/HigherOrSameThanVersion", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectStoreHigherOrSameThanVersionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectStore_HigherOrSameThanVersionClient interface {
	Recv() (*KeyList, error)
	grpc.ClientStream
}

type objectStoreHigherOrSameThanVersionClient struct {
	grpc.ClientStream
}

func (x *objectStoreHigherOrSameThanVersionClient) Recv() (*KeyList, error) {
	m := new(KeyList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectStoreClient) DoesExist(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*ExistResponse, error) {
	out := new(ExistResponse)
	err := grpc.Invoke(ctx, "/objectstore.ObjectStore/DoesExist", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ObjectStore service

type ObjectStoreServer interface {
	// Put (with a known ID). Maximum object RPC size applies.
	// Only suitable for tiny little objectlets
	PutWithID(context.Context, *PutWithIDRequest) (*common.Void, error)
	// return an object by (error if it does not exist)
	// Maximum object RPC size applies.
	// Only suitable for tiny little objectlets
	Get(context.Context, *GetRequest) (*Object, error)
	// like PutWithID, but for large objects
	LPutWithID(ObjectStore_LPutWithIDServer) error
	// like Get, but for large objects
	LGet(*GetRequest, ObjectStore_LGetServer) error
	// get a list of objects in store
	List(context.Context, *ListRequest) (*ListResponse, error)
	// sync disk and db
	TriggerCheckDisk(context.Context, *common.Void) (*common.Void, error)
	// put an object, but only if it does not exist yet
	PutIfNotExists(context.Context, *PutWithIDRequest) (*PutResponse, error)
	// get an object, if it exists
	TryGet(context.Context, *GetRequest) (*GetResponse, error)
	// remove an object, return object if it was present
	Evict(context.Context, *EvictRequest) (*GetResponse, error)
	// get all object-keys with a version higher than...
	HigherOrSameThanVersion(*ByVersionRequest, ObjectStore_HigherOrSameThanVersionServer) error
	// check if key exists
	DoesExist(context.Context, *GetRequest) (*ExistResponse, error)
}

func RegisterObjectStoreServer(s *grpc.Server, srv ObjectStoreServer) {
	s.RegisterService(&_ObjectStore_serviceDesc, srv)
}

func _ObjectStore_PutWithID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutWithIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectStoreServer).PutWithID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectstore.ObjectStore/PutWithID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectStoreServer).PutWithID(ctx, req.(*PutWithIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectStore_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectStoreServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectstore.ObjectStore/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectStoreServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectStore_LPutWithID_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ObjectStoreServer).LPutWithID(&objectStoreLPutWithIDServer{stream})
}

type ObjectStore_LPutWithIDServer interface {
	SendAndClose(*common.Void) error
	Recv() (*PutWithIDRequest, error)
	grpc.ServerStream
}

type objectStoreLPutWithIDServer struct {
	grpc.ServerStream
}

func (x *objectStoreLPutWithIDServer) SendAndClose(m *common.Void) error {
	return x.ServerStream.SendMsg(m)
}

func (x *objectStoreLPutWithIDServer) Recv() (*PutWithIDRequest, error) {
	m := new(PutWithIDRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ObjectStore_LGet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectStoreServer).LGet(m, &objectStoreLGetServer{stream})
}

type ObjectStore_LGetServer interface {
	Send(*Object) error
	grpc.ServerStream
}

type objectStoreLGetServer struct {
	grpc.ServerStream
}

func (x *objectStoreLGetServer) Send(m *Object) error {
	return x.ServerStream.SendMsg(m)
}

func _ObjectStore_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectStoreServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectstore.ObjectStore/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectStoreServer).List(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectStore_TriggerCheckDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectStoreServer).TriggerCheckDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectstore.ObjectStore/TriggerCheckDisk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectStoreServer).TriggerCheckDisk(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectStore_PutIfNotExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutWithIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectStoreServer).PutIfNotExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectstore.ObjectStore/PutIfNotExists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectStoreServer).PutIfNotExists(ctx, req.(*PutWithIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectStore_TryGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectStoreServer).TryGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectstore.ObjectStore/TryGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectStoreServer).TryGet(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectStore_Evict_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvictRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectStoreServer).Evict(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectstore.ObjectStore/Evict",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectStoreServer).Evict(ctx, req.(*EvictRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectStore_HigherOrSameThanVersion_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ByVersionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectStoreServer).HigherOrSameThanVersion(m, &objectStoreHigherOrSameThanVersionServer{stream})
}

type ObjectStore_HigherOrSameThanVersionServer interface {
	Send(*KeyList) error
	grpc.ServerStream
}

type objectStoreHigherOrSameThanVersionServer struct {
	grpc.ServerStream
}

func (x *objectStoreHigherOrSameThanVersionServer) Send(m *KeyList) error {
	return x.ServerStream.SendMsg(m)
}

func _ObjectStore_DoesExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectStoreServer).DoesExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectstore.ObjectStore/DoesExist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectStoreServer).DoesExist(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ObjectStore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "objectstore.ObjectStore",
	HandlerType: (*ObjectStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PutWithID",
			Handler:    _ObjectStore_PutWithID_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ObjectStore_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _ObjectStore_List_Handler,
		},
		{
			MethodName: "TriggerCheckDisk",
			Handler:    _ObjectStore_TriggerCheckDisk_Handler,
		},
		{
			MethodName: "PutIfNotExists",
			Handler:    _ObjectStore_PutIfNotExists_Handler,
		},
		{
			MethodName: "TryGet",
			Handler:    _ObjectStore_TryGet_Handler,
		},
		{
			MethodName: "Evict",
			Handler:    _ObjectStore_Evict_Handler,
		},
		{
			MethodName: "DoesExist",
			Handler:    _ObjectStore_DoesExist_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "LPutWithID",
			Handler:       _ObjectStore_LPutWithID_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "LGet",
			Handler:       _ObjectStore_LGet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "HigherOrSameThanVersion",
			Handler:       _ObjectStore_HigherOrSameThanVersion_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protos/golang.conradwood.net/apis/objectstore/objectstore.proto",
}

func init() {
	proto.RegisterFile("protos/golang.conradwood.net/apis/objectstore/objectstore.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 722 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x55, 0xeb, 0x4e, 0xdb, 0x48,
	0x14, 0x96, 0x93, 0x90, 0xcb, 0x71, 0x40, 0xd1, 0xec, 0x0a, 0xbc, 0x16, 0x2b, 0x45, 0xd6, 0x2e,
	0x8a, 0xd4, 0x2a, 0xd0, 0x20, 0x55, 0x95, 0xa0, 0x6a, 0x01, 0x47, 0x34, 0x22, 0x2d, 0x91, 0x49,
	0xa1, 0xea, 0x3f, 0x13, 0x1f, 0x92, 0x29, 0xc5, 0x93, 0x8e, 0x27, 0x94, 0xbc, 0x59, 0x1f, 0xa3,
	0x8f, 0x54, 0x79, 0x3c, 0x4e, 0xc6, 0xe1, 0x52, 0xca, 0xaf, 0xcc, 0x39, 0xdf, 0xb9, 0x7e, 0xf9,
	0x3c, 0x03, 0x6f, 0xc6, 0x9c, 0x09, 0x16, 0x6d, 0x0e, 0xd9, 0x57, 0x3f, 0x1c, 0x36, 0x07, 0x2c,
	0xe4, 0x7e, 0xf0, 0x9d, 0xb1, 0xa0, 0x19, 0xa2, 0xd8, 0xf4, 0xc7, 0x34, 0xda, 0x64, 0xe7, 0x5f,
	0x70, 0x20, 0x22, 0xc1, 0x38, 0xea, 0xe7, 0xa6, 0xcc, 0x24, 0xa6, 0xe6, 0xb2, 0x9b, 0x0f, 0x94,
	0x19, 0xb0, 0xab, 0x2b, 0x16, 0xaa, 0x9f, 0x24, 0xd9, 0xf9, 0x99, 0x03, 0x38, 0x96, 0xf9, 0xef,
	0x51, 0xf8, 0x64, 0x05, 0x72, 0x1d, 0xd7, 0x32, 0xea, 0x46, 0xa3, 0xe0, 0xe5, 0x3a, 0x2e, 0xa9,
	0x41, 0xfe, 0x08, 0xa7, 0x56, 0xae, 0x6e, 0x34, 0x2a, 0x5e, 0x7c, 0x24, 0x16, 0x94, 0x4e, 0x91,
	0x47, 0x94, 0x85, 0x56, 0x5e, 0x86, 0xa5, 0x66, 0x8c, 0x9c, 0x20, 0xbf, 0xa6, 0x03, 0xb4, 0x0a,
	0x32, 0x3e, 0x35, 0x63, 0xe4, 0x80, 0xa3, 0x2f, 0x18, 0xb7, 0x96, 0x12, 0x44, 0x99, 0xe4, 0x3f,
	0x58, 0xee, 0xfa, 0x91, 0xf0, 0x50, 0x70, 0x8a, 0xd7, 0x18, 0x58, 0xc5, 0xba, 0xd1, 0x58, 0xf6,
	0xb2, 0xce, 0x59, 0x3e, 0x06, 0x56, 0x49, 0xe2, 0xa9, 0x49, 0xea, 0x60, 0xc6, 0xa1, 0x1f, 0xc7,
	0x81, 0x44, 0xcb, 0x12, 0xd5, 0x5d, 0xc4, 0x86, 0xf2, 0x49, 0xcc, 0x4c, 0xbc, 0x46, 0x45, 0x36,
	0x9f, 0xd9, 0x72, 0xe2, 0xf8, 0xdc, 0x71, 0x2d, 0x48, 0xea, 0x2a, 0x93, 0xac, 0x42, 0xb1, 0x7d,
	0x33, 0xa6, 0x7c, 0x6a, 0x99, 0x12, 0x50, 0x16, 0x71, 0xa0, 0x2a, 0x43, 0x52, 0x0a, 0xaa, 0x92,
	0x82, 0x8c, 0xcf, 0x79, 0x0d, 0xcb, 0xed, 0x1b, 0x1a, 0xcf, 0x1f, 0x8d, 0x59, 0x18, 0xa1, 0x46,
	0x6a, 0x45, 0x92, 0xba, 0x0e, 0x15, 0x97, 0x61, 0x24, 0x83, 0x24, 0xb5, 0x65, 0x6f, 0xee, 0x70,
	0xfa, 0x50, 0xeb, 0x4d, 0xc4, 0x19, 0x15, 0xa3, 0x8e, 0xeb, 0xe1, 0xb7, 0x09, 0x46, 0xe2, 0x56,
	0x85, 0x98, 0x10, 0x16, 0x0a, 0x0c, 0x93, 0xfc, 0xaa, 0x97, 0x9a, 0xda, 0xe0, 0x79, 0x7d, 0x70,
	0x67, 0x1d, 0xe0, 0x10, 0xc5, 0x3d, 0xf5, 0x9c, 0x16, 0x14, 0x13, 0x11, 0x3c, 0xbe, 0x93, 0xb3,
	0x07, 0xd5, 0xae, 0xbe, 0xe5, 0x0b, 0x28, 0x25, 0x35, 0x22, 0xcb, 0xa8, 0xe7, 0x1b, 0x66, 0x6b,
	0xad, 0xa9, 0x6b, 0x75, 0x2e, 0x32, 0x2f, 0x8d, 0x73, 0xfe, 0x07, 0x33, 0x29, 0x91, 0x4c, 0xb5,
	0x0a, 0xc5, 0x1e, 0xc7, 0x0b, 0x7a, 0xa3, 0xfa, 0x2b, 0xcb, 0x69, 0x83, 0xd9, 0x9b, 0xcc, 0x1b,
	0xd9, 0x50, 0x3e, 0xf3, 0xa3, 0xbd, 0x20, 0xc0, 0x40, 0x06, 0x96, 0xbd, 0x99, 0x1d, 0x63, 0x2e,
	0x0d, 0x74, 0x66, 0x67, 0xb6, 0xf3, 0x09, 0x4c, 0x49, 0x81, 0x2a, 0x93, 0xf9, 0x17, 0x8c, 0x85,
	0x7f, 0x81, 0x3c, 0x4b, 0x19, 0x91, 0x65, 0xcc, 0xd6, 0x5f, 0x77, 0x2c, 0xe3, 0xa9, 0x10, 0x67,
	0x1f, 0xaa, 0xed, 0x6b, 0x3a, 0xb8, 0x8f, 0xde, 0x58, 0x35, 0x1e, 0x8a, 0x09, 0x0f, 0xb5, 0x92,
	0x65, 0x2f, 0xe3, 0x73, 0x9e, 0x43, 0x6d, 0x7f, 0xaa, 0x24, 0x94, 0xd6, 0xd1, 0xbe, 0x35, 0x23,
	0xf3, 0xad, 0x39, 0xbb, 0x50, 0x3a, 0xc2, 0x69, 0x4c, 0xde, 0x13, 0x78, 0x6f, 0xfd, 0x58, 0x02,
	0x33, 0x39, 0x4b, 0xe1, 0x92, 0x57, 0x50, 0x99, 0x49, 0x8e, 0xfc, 0x9b, 0x49, 0x5f, 0x94, 0xa2,
	0x5d, 0x6d, 0xaa, 0xfb, 0xe3, 0x94, 0xd1, 0x80, 0x6c, 0x43, 0xfe, 0x10, 0x05, 0xc9, 0xb6, 0x9c,
	0x0b, 0xcd, 0xbe, 0x8b, 0x36, 0xb2, 0x03, 0xd0, 0x7d, 0x5a, 0xbf, 0x86, 0x41, 0x5e, 0x42, 0xa1,
	0xfb, 0xc7, 0x2d, 0xb7, 0x0c, 0xb2, 0x03, 0x05, 0x49, 0x97, 0x95, 0x81, 0x35, 0xf9, 0xd9, 0xff,
	0xdc, 0x81, 0x28, 0xad, 0x34, 0xa1, 0xd6, 0xe7, 0x74, 0x38, 0x44, 0x7e, 0x30, 0xc2, 0xc1, 0xa5,
	0x4b, 0xa3, 0x4b, 0x92, 0x19, 0x6c, 0x81, 0x96, 0x0e, 0xac, 0xf4, 0x26, 0xa2, 0x73, 0xf1, 0x81,
	0x09, 0x29, 0xa7, 0xe8, 0x77, 0x5b, 0x5a, 0x8b, 0xf0, 0xac, 0xf5, 0x0e, 0x14, 0xfb, 0x7c, 0xfa,
	0xe0, 0xc6, 0xd6, 0x6d, 0x40, 0x25, 0xef, 0xc2, 0x92, 0x14, 0x26, 0xc9, 0xee, 0xa6, 0x8b, 0xf5,
	0x81, 0xec, 0x1e, 0xac, 0xbd, 0xa3, 0xc3, 0x11, 0xf2, 0x63, 0x7e, 0xe2, 0x5f, 0x61, 0x7f, 0xe4,
	0x87, 0xe9, 0x5d, 0x9f, 0x5d, 0x67, 0x51, 0xb8, 0xf6, 0xdf, 0x19, 0x58, 0x29, 0x75, 0xcb, 0x20,
	0x6f, 0xb5, 0x6f, 0xee, 0xfe, 0x7d, 0xec, 0xec, 0xb0, 0xfa, 0x5d, 0xba, 0xdf, 0x83, 0x8d, 0x10,
	0x85, 0xfe, 0xbc, 0xa9, 0x07, 0x2f, 0x7e, 0xe1, 0xf4, 0xbc, 0xcf, 0x1b, 0x8f, 0x7b, 0x50, 0xcf,
	0x8b, 0xf2, 0x21, 0xdc, 0xfe, 0x15, 0x00, 0x00, 0xff, 0xff, 0x22, 0xa3, 0x1b, 0x04, 0x88, 0x07,
	0x00, 0x00,
}






